<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[计算机体系结构基本概念]]></title>
    <url>%2F2019%2F10%2F05%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[​ 体系结构是操作系统和硬件中间的一个抽象层，对于一款CPU而言，绝对的硬件技术水平不是最重要的，体系结构对指导硬件实现和对于系统发挥性能来说是更关键的部分。本科的时候学过一门课《计算机组成与体系结构》，当时老师懂得多，讲得也很好，奈何当时太年轻，不知道好好学,,ԾㅂԾ,,……今天重新把这些概念拾一拾。 1. 引言 计算机的发展 计算机生产技术的发展。进步一直很稳定，但近来逼近物理极限。 计算机设计的创新。体系结构方面 体系结构的成功 人们不再使用汇编编程，降低了对目标代码的兼容性 出现了独立于厂商的标准化操作系统Unix以及linux等。降低了引入新体系结构的风险、成本。 RISC体系结构设计的创新点（或者说关键技术） 指令级并行的开发。流水线、多指令发射 缓存的使用，更复杂的组织和优化方式。 单核处理器性能提升结束。硬件复兴结束。以下两大瓶颈，转而寻求一个芯片上提高集成核心的数目，而不是加快单核处理器的速度。 风冷芯片最大功耗问题 无法有效地开发更多指令级并行 转折：处理器性能的提高从单纯依赖指令级并行(ILP)，转向数据级并行（DLP）和线程级并行（TLP）。还有请求级并行（RLP） 2. 并行体系结构分类和实现 应用程序中主要有以下两种并行。 数据级并行。同时操作许多数据项 任务级并行。创建了一些能够单独处理，但大量采用并行方式执行的工作任务 计算机以如下4种主要方式来开发上述两种应用并行 指令级并行。流水线、推理执行、多指令发射 标量流水（Super Scalar) 将一条指令分成若干个周期处理以达到多条指令重叠处理,从而提高cpu部件利用率的技术叫做标量流水技术。 即对每条指令的执行进行更细的划分来支持流水线操作，需要微操作（micro operation）的支持。 超级标量是指cpu内一般能有多条流水线,这些流水线能够并行处理.在单流水线结构中,指令虽然能够重叠执行,但仍然是顺序的,每个周期只能发射(issue)或退休(retire)一条指令.超级标量结构的cpu支持指令级并行,每个周期可以发射多条指令(2-4条居多).这样,可以使得cpu的IPC(InstructionPer Clock) &gt; 1, 从而提高cpu处理速度. 超级标量机能同时对若干条指令进行译码，将可以并行执行的指令送往不同的执行部件,在程序运行期间，由硬件(通常是状态记录部件和调度部件)来完成指令调度. 超级标量机主要是借助硬件资源重复(例如有两套译码器和ALU等)来实现空间的并行操作. 即 硬件上支持多条指令的流水线。支持乱序发射，乱序执行。 超级流水技术：主要是指硬件上流水线结构切分的更细了，CPU的主频可以提得更高；缺点就是：流水线级数越多，重叠执行的执行就越多，那么发生竞争冲突得可能性就越大。latency也变得更大了。 超长指令字：是一条指令来实现多个操作的并行执行。每条指令长度达上百位，可以执行多个操作，可以减少内存访问次数。 这个级别得并行，是由编译器来决定并且组织得。通常VLIW机只有一个控制器，每个周期启动一条长指令，长指令被分为几个字段，每个字段控制相应的部件。由于编译器需要考虑数据相关性，避免冲突，并且尽可能利用并行，完成指令调度，所以硬件结构较简单。 向量体系结构和图形处理器（GPU）。将单条指令并行应用于一个数据集，以开发数据级并行。大型机，超级计算机 线程级并行。在紧耦合硬件模型中开发并行。此模型允许在并行线程之间进行交互。 请求级并行。在程序员或操作系统指定的大量去耦合任务之间开发并行。 3. 体系结构定义 区分计算机体系结构和微结构 体系结构(computer architecture)定义的是硬件和软件的接口，并没有指定实现。RISC-V即定义的体系结构。 微结构(processor microarchitecture)则描述的是如何设计一个处理器来符合一个体系结构。体系结构并不定义微结构。 现有指令集 CISC指令集的代表：x86和x86-64。 RISC指令集的代表：ARM(ARMv7,AArch32,AArch64,thumb, thumb2) 其他的指令集：MIPS, PowerPC, SPARC 3.1 指令集体系结构设计的7个维度 ISA的分类。被划归到通用寄存器体系结构中。有以下两种主流版本。 寄存器-存储器ISA：80x86.许多指令都可以访问存储器。 载入-存储ISA：ARM和MIPS。只能用载入load和存储store指令来访问存储器。 存储器寻址。 ARM和MIPS要求操作对象在存储器中必须是对齐的。即，若对象大小为s，字节地址为A，必须保证A mod s =0 。访问速度会快一些 80x86不需要对齐。 寻址模式。可以再回去看微机原理温习一遍。几种架构的寻址模式大同小异。 MIPS寻址模式：寄存器寻址、立即数寻址和位移量寻址。 操作数的类型和大小。 32位单精度：4个字节存储。64位双精度：8个字节存储。 操作指令. 数据传输指令、算术逻辑指令、控制指令和浮点指令 、IO指令，特殊指令。 控制流指令。均支持条件转移、无条件跳转、过程调用和返回。 ARM和MIPS过程调用将返回地址放在一个寄存器中 80x86将返回地址放在存储器的一个栈内。 ISA的编码。 固定长度。ARM和MIPS固定32位指令，简化了指令译码（后来又扩充了支持16位指令，以便缩小程序规模）。 可变长度，80x86编码可变长度，变化范围1-18个字节。可以占用较少的空间。 寄存器数目和寻址模式的数目都对指令的大小有显著影响。 3.2 体系结构与微结构的相互影响 处理器微结构 流水线 多发乱序流水线 多线程流水线 多核 特殊流水线：VLWI, vector, GPU 体系结构与微结构的互相影响 CISC和RISC的特性。 RISC的每条指令功能复杂度基本一致，执行时间基本一致，编码长度基本一致，流水线控制简单，指令调度简单，代码密度相对CISC较小。 CISC的指令功能复杂度不一，执行时间长短不一，编码长度也不一样。直接运行导致流水线控制复杂调度困难，一般动态拆做类似RISC的微指令执行。代码密度相对RISC较高。 操作数：单指令寄存器个数。从栈寻址到多寄存器寻址在代码密度，流水线调度，执行时间上的考虑。 操作数：内存寻址方式。RISC的内存寻址方式单一，调度简单，可做单独流水线，但指令密度高。CISC调度方式复杂，流水线设计复杂，指令密度高。 环境变量： 条件执行对流水线的影响。 指令编码：RISC编码和CISC编码，解码难度，取址难度，分支预测难度等等。 编译器： 编译器是指令集和高级语言的接口。 语言的抽象等级越高，ISA的使用就更加受限：ABI，systemcall，context switching。 通用逻辑寄存器的功能异化，数量对编译器的影响。 操作系统：硬件资源的管理者，特权软件。 操作系统需要ISA的支持：控制寄存器，特权指令，内存模型，IO模型等等，hyervisor模式。]]></content>
      <categories>
        <category>计算机体系结构</category>
      </categories>
      <tags>
        <tag>concepts</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SCA：简单能量分析攻击]]></title>
    <url>%2F2019%2F08%2F19%2FSCA%EF%BC%9A%E7%AE%80%E5%8D%95%E8%83%BD%E9%87%8F%E5%88%86%E6%9E%90%E6%94%BB%E5%87%BB%2F</url>
    <content type="text"><![CDATA[​ 最近参加了一个侧信道攻防相关的培训，写一个系列来总结记录一下。知识比较碎片化，在整理的时候力求能系统一点，但是重点还是放在自己的一些理解与体会上。 1. 理论理解1.1 侧信道​ 所有的敏感密码算法最终都是跑在实际的物理机器上的。既然是运行在实际的物理机器上，那就会不可避免和物理世界产生一些交互。侧信道攻击指的就是通过这些物理泄露来获取密钥信息。相比于密码学（偏数学分析）分析攻击，这种攻击方法的效率大大提高。在近年来已经取得了很多成果。比如系里的XX老师就常年把曾经攻破XX城市的智能交通卡挂在嘴边。侧信道信息的泄露面基本有下图几种，但不是每种信息都会对应到一个特定的攻击方法。比如，我们采集到的功耗信息、或者电磁辐射信息其实都是内部电路运行状态的直接反映，采集到的波形，可以用同一种方法来进行分析。（比如简单能量分析、相关能量分析等等）这些将在后边的例子中有一些体现。 ​ 1.2 简单能量分析攻击SPA​ 区别与差分能量分析攻击（后边会讲），没有或者不利用不同密钥输入得到的信息来去比对、确认之类的操作。说白一点，就是把能量轨迹显示出来，用眼睛“看”。如下图，DES算法的软件实现中，做能量轨迹分析，可以清楚的看到16轮的加密的过程。 这种攻击一般会有以下几个假设： 攻击者可以驱动被攻击设备至少一次加密（或者解密，密钥要可以参与运算）。 采集设备加密过程中的能量波形 找到感兴趣的某个操作在波形上的准确位置。 密钥信息能够体现在这个操作的不同波形上，即不同操作的波形对比要明显一些。 优点：不需要太多的能量轨迹 缺点：1. 需要泄露比较明显，适合那种简单的软件平台的实现（MCU、CPU）。毕竟现在很多密码算法在实现过程中都考虑了硬件固化，侧信道防护。但凡安全级别高一点的，就很难满足这个条件。2. 对噪声比较敏感。 2. 攻击实验2.1 目标算法：DES中的置换操作​ DES中有一个步骤是将56bits的密钥做PC-1置换。如下图，假如输入为A，根据算法定义（规定），将A中的bit填到B中的固定位置。 ​ ​ 上述置换，一个程序员的典型软件实现思路应该是这样的： 把 B 清 0 把A中的比特编号进行56次循环： 如果A[i]=0，则什么都不做。跳转（因为B已经初始化，节省一个数据移动操作） 如果A[i]=1，则查表得知这个1在B中的去向，并写入B相应的位置。（不跳，执行下一条的写操作） ​ 上述伪代码的软件实现可以清楚观测出芯片内部正在运行什么操作。进而直接恢复原始密钥A的值。上述代码如果拿汇编写的话，可以对应如下: 2.2 目标待攻击平台算法运行平台：AT89S52 12M晶振，即时钟12M，但是因为平台特点，一个指令周期需要12个cycles，所以一个指令周期的时间大约为1位秒。 实际的攻击场景，是可以满足这个对待攻击平台具体硬件参数了解的条件的。 2.3 攻击步骤建模板观察根据上述的攻击假设，我们是有机会拿到空白的硬件设备，并且写入明文和密钥的。这一步写入特定的密钥，观察芯片在执行上述置换操作时，跳转与不跳转写入的能量波形区别。如下图，设置示波器的一些显示参数，(示波器可以设置采集窗口，这一窗口可以通过另一个通道加入，激励来源可以是攻击者操作过的加密平台)，通过示波器采集到的能量波形如下图所示：其中红色为实时采集波形，蓝色为示波器的trigger波形，可以理解为采样窗口。黑色线条为经过示波器数字滤波求平均后的波形。 观察上图中经过均值滤波后的黑色曲线，可得出如下图中的规律。 既然我们可以认为写入密钥，那就可以先把前两个bit写个01试试，结合上图得出的规律，我们只需要把0和1对应上就可以，如下图： 假如，前两个bit 01是用来建立模板，观察相应操作对应波形的，那么就可以确认：四小对应跳转，两小一中对应不跳转，一大一小对应写入。 密钥破解通过上述分析就可以得出后续波形分别对应的是什么操作，进而能恢复出每个bit的信息来。当获得真实的加密设备后，能量波形对应微操作，微操作对应密钥，攻击的目的也就达到了。 其他能量波形的采集方法除了上述的是直接在芯片的电源输入端串接电阻外，还可以用线圈来采集电磁泄露信息，进而得到能量波形。如下图： 显然，通过电磁信息泄露采集能量波形，对客观环境要求比较严格。这个比较简单，也能直接恢复出来。但是考虑复杂情况的话，不仅容易收到周围电磁场的干扰，而且还需要做电磁泄漏的空间定位（线圈放在哪里）等等。 3 简单能量分析攻击的其他示例3.1 RSA算法的简单能量分析RSA算法中，密钥参与的有一个运算是幂方运算，密钥就是幂方，底数可以看作消息。幂方运算采用的快速算法是下图右半部分的算法。即幂方的比特形式，一位一位的去算。 因为这个密钥bit 0和1的差异，为了高效实现，当为0时，是可以少一个乘运算的。而且硬件电路中专门有平方运算的优化，所以平方和乘运算，所对应的微操作，可以认为是不同的。这样我们就可以通过能量波形来判断微操作的类型，进而判断密钥是什么。 类似的案例还有很多。 思考不可避免洛卡尔物质交换定律： 犯罪行为人只要实施犯罪行为，必然会在犯罪现场直接或间接地作用于被侵害客体及其周围环境，会自觉或不自觉地遗留下痕迹。 侧信道信息就是这样，密码算法在实现过程中、芯片运行过程中，总是要和物理世界产生信息交互的。而防止侧信道攻击的思想，就是尽可能地减弱这些侧信道信息和密码算法关键数据的相关性。 简单能量分析防护讲回本篇提到的这个简单能量分析，因为程序中分支执行的不一致，带来微操作的差别，给了直接分析可乘之机，而且密钥的恢复效率比密码学分析方法高的太多了。上述微操作和能量波形的匹配，也是可以交给工具去做的。首先对原始波形滤波，然后挑选有意义的波形，做波切割（对应微操作），这一过程人眼参与的比较多。然后设定标准段，与其他切割段作对比，恢复密钥。 要防护这类攻击，也比较简单，首先，并行执行就给攻击带来了很多难度；其次，可以讲不同分支对齐，甚至减少关键部分运算的分支。]]></content>
      <categories>
        <category>硬件安全</category>
      </categories>
      <tags>
        <tag>密码算法，硬件攻防</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[密钥管理]]></title>
    <url>%2F2019%2F08%2F01%2F%E5%AF%86%E9%92%A5%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[​ 芯片生命周期设计的几个关键点包括：密钥管理，安全的密钥管理，保证了各个环节信息密文的导入，是安全性的根本性保障；固件管理，不同时期的固件密文导入，与固件的导入校验以及固件的升级更新；测试端口，芯片设计、使用的不同时期提供不同的测试功能，部分功能关闭或打开。本篇主要学习一下密钥管理过程涉及的一些概念 1.密钥分层管理结构密钥的安全管理通常采用层次化的保护方式。密钥的分层管理机制通常把密钥分为三层，即：根密钥、密钥加密密钥和工作密钥，下层的密钥为上层密钥提供加密保护。 工作密钥; 对外表现密钥。 工作密钥对本地保存的敏感数据和需要在不安全信道上传输的数据提供机密性、完整性保护，还可提供认证和签名等密码学服务。工作密钥直接被上层应用程序所使用，包括存储加密使用的密钥、预共享密钥、MAC密钥、签名私钥等。 密钥加密密钥；中间密钥。 对工作密钥提供机密性保护的密钥，其自身受到根密钥的保护。对于较为简单、安全等级要求不高的密码应用系统，密钥加密密钥的职能可以直接由根密钥兼任。 根密钥； 位于密钥管理分层结构的最底端，用于对上层密钥（如密钥加密密钥）的机密性进行保护。 规则：密钥分层管理至少选择两层结构进行管理 说明: 密钥的分层管理机制最少把密钥分为两层，即：根密钥和工作密钥，根密钥为工作密钥提供加密保护。以下场景更倾向于选择三层的密钥管理机制： 根密钥更新过程产生大量的加解密运算开销 在应用系统中，如果使用根密钥直接保护工作密钥，根密钥的更新会导致所有受其加密保护的工作密钥需要全部使用更新前的根密钥解密，再重新使用更新后的根密钥加密。当工作密钥数量比较庞大时，对工作密钥的解密和加密操作将耗费大量的资源并影响系统的性能。 在根密钥和工作密钥之间增加一层密钥加密密钥（KEK），密钥加密密钥对工作密钥进行加密保护，根密钥则对KEK进行加密保护。当根密钥更新时，只需要解密和重新加密KEK即可，由于KEK的数量远远小于工作密钥数量，对KEK的解密和加密操作不会消耗大量资源，对系统的性能影响很小。当KEK更新时，将需要被更新的KEK和被其保护的工作密钥都保存成历史密钥信息。应用系统需要解密被历史密钥信息加密的数据时，直接使用历史密钥解密即可。 系统要求频繁的进行工作密钥更新 典型的应用场景是工作密钥作为通信密钥（可能要求每次会话都被要求使用不同的密钥）。该场景下的工作密钥更新过程通常在线进行，需要使用工作密钥的下层密钥加密保护工作密钥的传输过程。 如果使用根密钥直接保护工作密钥，根密钥加密的密文会频繁的在不安全的信道上传输，并易于被攻击者截获。攻击者可以通过分析大量密文破解根密钥。虽然通过更新根密钥的方法可以有效避免上述对根密钥的攻击，但根密钥更新周期一般较长，且一般使用手动方式更新，无论采用白盒密码还是基于密钥组件的根密钥保护方案，根密钥的更新操作都较为繁琐，难以广泛的适应该应用场景的要求。 应用系统结构复杂 如果应用系统中包含两个或者两个以上的子系统，各子系统之间的业务相互独立，每个子系统都为用户提供不同的服务。在这样的场景下，各子系统使用的密钥应该各不相同。如果不同的应用系统之间使用的工作密钥都被根密钥保护，根密钥的泄露将导致各子系统由密码机制保障的安全性完全失效。为解决上述问题，推荐使用三层密钥管理结构，在根密钥和工作密钥之间增加一层密钥加密密钥（KEK），为每个子系统分配各自的KEK，这样即使某一个子系统的KEK泄露，密码安全机制失效的威胁仅也限于该子系统内，不会影响其他子系统的安全性。 Example：密钥在真实芯片系统中，其派生可以是下图的方式： 2. 密钥生命周期一个密钥在其生命周期中会经历多种不同的状态。密钥在其生命周期的各个阶段，都应满足一些基本的安全要求，以保障自身的安全性。 2.1 密钥生成常用的密钥生成方式包括： 基于安全的随机数发生器 基于密钥导出函数 基于标准的密钥协商机制。（比如密钥交换协议/密钥封装机制KEM） 基于安全的密钥生成工具等。 利用随机数发生器、密钥导出函数、密钥协商等方式来生成密钥，均应遵循一些规则，以使产生的密钥足够安全。 Example：密钥在真实芯片世界的导入过程 2.2 密钥更新工作密钥及密钥加密密钥在使用过程中，都应保证其可以更新。对于根密钥暂不要求必须支持可更新。密钥可更新才能保证密钥使用的安全，原因如下： 密钥使用时间越长，攻击者花费精力去破解它的诱惑也越大，这使得密钥被破解的风险也越大； 密钥加密的数据量越多，攻击者能够获取到密文的数据机会也越大，而对被同一个密钥加密的多个密文进行密码学分析相对比较容易，导致密钥越容易被破解； 如果密钥已经泄露，那么密钥被使用的时间越久，损失越大。 密钥的更新一般有如下两种方式： 系统定期自动更新密钥。 执行密钥更新时，系统根据密钥生成的规则，重新生成新密钥，同时使用旧密钥解密已加密的数据，并使用新生成的密钥重新加密，同时销毁旧密钥；对于加密数据量很大的场景，可以考虑保留旧密钥，用于解密旧密钥加密的数据，同时使用更新后的密钥加密新数据。此方式适用于系统可自主生成密钥的场景。 管理员手动更新]]></content>
      <categories>
        <category>信息安全概念</category>
      </categories>
      <tags>
        <tag>concepts</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[综合与DC(一)：基本概念]]></title>
    <url>%2F2019%2F07%2F15%2F%E7%BB%BC%E5%90%88%E4%B8%8EDC(%E4%B8%80)%EF%BC%9A%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[​ 写一个系列吧，从综合与DC写起，算是前端的一部分。后边会跟上后端，以及前端的一些经典电路、模块的设计，EDA工具的使用。 1. 前言​ 现在的电路规模已经达到百万门、千万门，SOC更甚之。人力在这种规模面前显得就太苍白渺小了，所以EDA工具在现代集成电路设计流程中有着举足轻重的作用。电路设计人员主要面向的还是EDA的使用，而不是底层的优化算法、调度控制等等。 ​ 本科的时候，学过一些EDA工具的使用，vcs、dc、ICC、PT、SPICE等（吹爆强哥）。但由于当时知识和动手能力的局限性，只是流于皮毛，大概知道了每个工具是做什么的，没有在具体的设计中深入研究、使用过。上学期，课程设计有机会从前到后都跑了一遍。最近，在看论文之余，希望能借助一些书、一些大牛博客以及厂商给的workshop，再把重点强化一些，把精细化分工的各个环节再过一遍。 2. 逻辑综合概述​ 基本的综合可以用一个等式来表达：synthesis = translation + logic optimization + gate mapping。 ​ 下面通过三张图来整体把握以下DC在IC设计中所处的环节、以及主要完成的工作。 2.1 图1 设计之前，准备好库、HDL代码的思想、约束生成；然后根据设计思想用 RTL 源码详细地、完整地为设计建立模型、定义设计中寄存器结构和数目、定义设计中的组合电路功能、定义设计中寄存器时钟等等的设计规格和实现。 完成 RTL 源码设计之后,应让设计开发与功能仿真并行进行. 在设计开发阶段,我们使用 DC 来实现特定的设计目标(设计规则和优化约束),以及执行默认选项的初步综合. 如果设计开发结果未能在 10%的偏差范围内满足时序目标,则需要修正 HDL 代码,然后重复设计开发和功能验证的过程 在功能仿真中,通过特定的工具来确定设计是否能按如所需的功能工作 如果设计未能满足功能要求, 我们必须修改设计代码以及重复设计开发和功能仿真. 继续设计开发和功能仿真直至设计功能正确及满足小于 10%偏差的时序目标. 使用 DC 完成设计的综合并满足设计目标.这个过程包括三个步骤，即综合=转化+逻辑优化+映射，首先将 RTL 源代码转化为通用的布尔等式（Gtech），然后设计的约束对电路进行逻辑综合和优化，使电路能满足设计的目标或者约束，最后使用目标工艺库的逻辑单元映射成门级网表，在将设计综合成门级网表之后,要验证此时的设计是否满足设计目标.如果不能满足设计目标,此时需要产生及分析报告确定问题及解决问题. 当设计满足功能、时序以及其他的设计目标的时候,需要执行物理层设计最后分析物理层设计的性能，也就是使用DC的拓扑模式，加入floorplan的物理信息后进行综合分析设计的性能。如果结果未能满足设计目标,应返回第三步.如果满足设计目标,则本部分设计周期完成. 2.2 图2 ​ 图2将图1中DC内的部分细化。在综合的时候，首先DC的HDL compiler把HDL代码转化成DC自带的GTECH格式，然后DC的library compiler 根据标准设计约束（SDC）文件、IP-DW库、工艺库、图形库、（使用拓扑模式时，还要加入ICC生成的DEF模式，加载物理布局信息）进行时序优化、数据通路优化、功耗优化（DC的power compiler进行）、测试的综合优化（DC的DFT compiler），最后得到优化后的网表。 2.3 图3 ​ 图三为DC内部的综合流程图，以及相应的一些命令 2.3.1 准备设计文件，coding工作。### 2.3.2 指定库文件、工作目录等。==补充命令示例==指定库文件，需要指定的库文件包括：链接库（link library） 、目标库（target library） 、符号库（symbol library）、综合库（synthetic library） Link library &amp; target library。Link library 和 target library 统称为 technology library（即工艺库，习惯称之为综合库），technology library 由半导体制造商提供，包含相关 cell 的信息及设计约束标准，其中：Target library: 在门级优化及映射的时候提供生成网表的 cell,即DC 用于创建实际电路的库。 Link library: 提供设计网表中的 cell，可以跟target_library使用同一个库，但是 DC 不用 link library中的 cell 来综合设计。当 DC 读入设计时，它自动读入由 link library 变量指定的库。当连接设计时，DC 先搜寻其内存中已经有的库，然后在搜寻由 link library 指定的库。 注：当读入的文件是门级网表时，需要把 link library 指向生成该门级网表的库文件，否则 DC 因不知道网表中门单元电路的功能而报错。 Symbol library.Symbol library 提供 Design Vision GUI 中设计实现的图形符号，如果你使用脚本模式而不使用 GUI,此库可不指定 Symbol library Synthetic library。即为 Designware library ,名字上翻译是综合库，但却常称之为IP库，而不是直译。特殊的 Designware library 是需要授权的（比如使用多级流水线的乘法器），默认的标准 Designware 由 DC 软件商提供，无需指定。 Create_mw_lib :主要使用DC的物理综合的时候，需要生成物理库 2.3.3 读入设计。设计的读入过程是将设计文件载入内存，并将其转换为 DC 的中间格式,即GTECH 格式，GTECH 格式由“soft macros” 如 adders, comparators 等组成，这些组件来自 synopsys 的 synthetic lib，每种组件具有多种结构。读入设计有两种实现方法实现方法：read 和 analyze &amp; elaborate（实际上read 是 analyze 与 elaborate 的打包操作 ）。两种的主要区别如下表： 从中可以看到，analyze &amp; elaborate 可以自由指定设计库，并生成 GTECH中间文件前生成.syn 文件存储于 work 目录下，便于下次 elaborate 节省时间，一般选择 analyze &amp; elaborate 的方法读入设计。 2.3.4 定义设计环境。定义对象包括工艺参数（温度、电压等），I/O 端口属性（负载、驱动、扇出），统计 wire-load 模型，设计环境将影响设计综合及优化结果。这一步主要是针对库的选择。 这里的wire load model是根据自己设计的规模自己选定的，并没有后端布线的真实情况。所以并不会很准确。 2.3.5 定义设计约束。包括设计规则约束和优化约束，设计规则约束（design rule constraint）由工艺库决定，在设计编译过程中必须满足，用于使电路能按功能要求正常工作。设计优化约束定义了 DC 要达到的时序和面积优化目标，该约束由用户指定，DC 在不违反设计规则约束的前提下，遵循此约束综合设计。 2.3.6 选择编译策略。对于层次化设计，DC 中有两种编译策略供选择，分别为 top down 和 bottom up。在 top down 策略中，顶层设计和子设计在一起编译，所有的环境和约束设置针对顶层设计，虽然此种策略自动考虑到相关的内部设计，但是此种策略不适合与大型设计，因为 top down 编译策略中，所有设计必须同时驻内存，硬件资源耗费大。在 bottom up 策略中，子设计单独约束，当子设计成功编译后，被设置为 dont_touch 属性，防止在之后的编译过程中被修改，所有同层子设计编译完成后，再编译之上的父设计，直至顶层设计编译完成。Bottom up 策略允许大规模设计，因为该策略不需要所有设计同时驻入内存。 2.3.7 编译用 Compile 命令执行综合与优化过程，还可以利用一些选项指导编译和优化过程。 2.3.8 分析及解决设计中存在的问题DC 可以产生一些报告以反映设计的综合和优化结果，如：时序、面积、约束等报告，这些报告有助于分析和解决设计中存在的问题以改善综合结果，我们还可以利用 check_design 命令检验综合的设计的一致性。 2.3.9 导出设计数据DC 不会自动存储综合后的设计结果，因而需要在离开 DC 时手动存储设计数据。比如存储网表、延时信息等数据文件。 3. Reference[1]：Tcl与Design Compiler （三）——DC综合的流程 基本概念都是来自这位同行的说法，只是对一些地方加了些自己的见解。下一篇中会补充上自己原来综合用的脚本。]]></content>
      <categories>
        <category>EE笔记</category>
      </categories>
      <tags>
        <tag>EDA，综合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客图床搭建]]></title>
    <url>%2F2019%2F07%2F14%2F%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%8A%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[​ 因为上次申请的七牛云存储空间是一个测试域名，一定时长后，域名就给失效了，所以原来博客里边素的没有一张图了（虽然一共也没有几篇博客）。因为不能上图，所以博客停更了几个月，这次趁着有时间，回来又申请了一个阿里云的OSS，这次主要记录一下图床的搭建吧！ 1. 账号注册及实名认证直接检索阿里云，然后可以拿支付宝登陆，绑定后，注册账号密码，并且完成实名制认证。完成认证之后，可以往里边充几块钱，以备后边的购买存储资源或者流量。 2. 开通OSS服务OSS就是对象存储服务的意思。在完成实名认证后，直接在官网入口点击，开通OSS服务就可以啦。目前还没有进入付费环节。然后在你OSS存储区的控制台，新建Bucket，如下图。然后通过下图中的购买链接进去，买存储包。 买存储包主要有以下几种选项，买了两年40G的，折算后竟然只有0.9…..让人吃惊。这羊毛薅的也太……. 买完存储包以后，再回到刚才新建Bucket的页面，刷新一下，然后忽视那个流量包的购买，直接选择公共读取权限，然后存储空间的购买就完成了。接下来，为了建立与图片上传工具的接口，需要获得自己的acesskey和secret。获取方式见下图，直接页面右上角点击自己的账户头像就能看到，然后点击acesskeys就可以获得了。 3.使用PicGo实现快速上传图片PicGo是一个开源项目，可以用来快捷上传图片到图床。可以去https://github.com/Molunerfinn/PicGo这个地址去下载picGo。下载最新版的release就可以啦。下载安装完成后，配置如下： accesskey和accesskeySecret是刚才从阿里云控制台获取的。存储空间名是bucket的名字。存储区域到阿里云OSS控制台去找，如下图，这里就填oss-cn-beijing就可以啦。 配置完接口后，将其阿里云oss设置为默认图床，然后可以根据自己的喜好去配置上传快捷键，至此，所有的工作就完成了。 以后又可以愉快地写博客了。]]></content>
      <categories>
        <category>工具使用</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>工具使用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[公钥加密基本概念（一）]]></title>
    <url>%2F2019%2F04%2F15%2F%E5%85%AC%E9%92%A5%E5%8A%A0%E5%AF%86%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[公钥密码学参考知乎文章《公钥密码学》 ​ 当代密码学的核心是公钥密码学。我们先来聊聊公钥密码学的定义，然后介绍一下它的两大应用，最后简要介绍一下两个公钥密码学的算法。Peter 写本文的目的是梳理清楚学习密码学的大思路，以便在看文档的时候，遇到椭圆曲线，RSA ，加密通信，数字签名这些术语的时候，起码知道它们的大致归属。 定义先来聊公钥密码学的定义。公钥密码学也称为非对称密码学，基本的意思就是在加密和解密的时候使用不同的秘钥，也就是 key ，其中一个是公钥，是可以公开出去的，另外一个是私钥，要严格保密。 但是公钥密码学的应用其实不局限于加密。公钥密码学要实现的功能有两个：一个是保密，发送者需要是用接收者的公钥去加密信息，接收者就用自己的私钥去解密信息。另外一个功能就是认证，发出信息的人用私钥去进行数字签名来签署信息，这样任何人拿到公钥之后都可以去确认信息是不是由私钥持有人发出的。所以，公钥密码学有两个应用，一个是加密通信，另外一个是数字签名。 公钥密码学的安全源于基本的数学原理。公钥和私钥首先应该是有数学联系的，不然所谓的解密和签名操作也就不可能实现了，但是同时不能由公钥去算出私钥，如果可以算出来，那么安全性就丧失了。所以加密算法都是基于一些目前无解的数学问题，或者叫单向函数，例如整数分解或者离散对数。具体的算法有 RSA 和 ECC 等。什么叫单向函数呢？8616460799 是两个数相乘得到的，给这两个数，可以很容易算出结果，但是如果给出结果，要分解出两个乘数，就是一个数学上还没有解决的问题，叫做”整数分解“问题。换句话说，如果有一天整数分解问题解决了，攻击者就可以把公钥分解，那么私钥就很容易被算出来了，基于整数分解的加密算法也就失效了。 稍微总结一下，公钥密码学的应用方向有两个，一个是加密通信，另外一个是数字签名。公钥密码学之所以可行，底层源于数学原理。 应用接下来，我们聊聊加密通信和数字签名的基本原理。 先说加密通信。Bob 需要先在自己的机器上生成公钥和私钥，然后把自己的公钥发送给 Alice 。这样，Alice 就可以给 Bob 发信息了。Alice 会用 Bob 的公钥把信息加密得到密文，密文传输过程中如果被截获是不用担心的，因为只有 Bob ，或者说只有私钥才能解密密文。这就是加密通信的基本过程。使用一个形象的比喻，Alice 要给 Bob 写信，首先需要知道 Bob 家的地址，而公钥就是地址。Alice 的信送到 Bob 的邮箱里之后，只有 Bob 用自己的邮箱钥匙，才能拿到信，所以私钥就是邮箱钥匙。 再说数字签名。Alice 要在网上签署一份合同，所以她就用私钥去签署合同，这样能生成一段数据，这个数据就是数字签名了。然后 Alice 把公钥公布给所有人，这样任何人都可以用公钥去解密数字签名，解密成功，也就证明了这份合同的确是 Alice 签署的。同时，如果有人篡改了这份合同，那么解密过程也会失败，所以说数字签名还有防止篡改的功能。要注意，数字签名过程中，合同本身并没有被加密。我们也来做一个形象的比喻。Alice 写一封信给家里人，写好之后，用自己的印章给信封加上蜡封。家人收到信之后，根据蜡封上的图案就能判断信是 Alice 写的，同时蜡封没有损坏，表示信没有被拆开篡改过。数字签名就相当于这个蜡封。 这就是公钥密码学的两大应用了，加密通信和数字签名。 补充公钥密码学还会用于密钥交换领域。目前自己做的还没有涉及到。 主要算法最后我们来聊聊公钥密码学的具体算法的诞生，最知名的算法有两个，一个是 RSA 算法，一个是 ECC 算法。 RSA 算法是开山鼻祖。1970 年，一位英国密码学家预见了“无秘密加密”的可能性，公钥加密思想产生了。公钥加密的比对称加密有明显优势，因为通信之前，双方不用传递密码，只需要传递公钥即可，而公钥不是秘密，被截获也不会影响通信安全。之后几年，人们开发了 RSA 算法，第一次真正实现了这个想法。RSA 算法标志着公钥密码学真正诞生了。RSA 算法的安全性基于整数分解问题，具体来说就是根据大素数相乘的结果，不可能被反向分解的数学原理。RSA 具体的数学推导不是那么复杂，看看对应的文章就能明白。 后来，人们发明了另外一种加密算法叫做 ECC ，也就是椭圆曲线算法。世界上不可解的数学问题并不是只有整数分解一个，ECC 就是基于另外一个问题：离散对数。一个加密算法的安全性取决于，由公钥去运算私钥的难度。毕竟私钥的位数是有限的，所以即使用暴力搜索的方式，也肯定是能够算出来的。而且各种单向函数虽然无解，但是不代表不能缩小求解范围，所以不同的算法其实安全性还是有差别的。而 ECC 用离散对数原理，同样的 Key 长度，安全性比 RSA 更高。比特币就是用 ECC 来生成地址和私钥。这里你可能会有疑问，为何不能把私钥位数尽量弄长一些呢？的确，越长就越安全，但是同时执行效率也低，所以实际使用中还是要保证一种平衡的。 这里我们要记住的是，加密算法很多，但是最重要的就是 RSA 和 ECC 两个，同时加密算法跟哈希算法是两个东西，所以 SHA1 ，MD5 这些哈希算法跟 RSA 和 ECC 根本不是一类，不要弄混淆。 补充哈希函数主要用来形成摘要 总结首先公钥密码学是基于单向函数的数学原理开发出来的，主要有两个应用，一个是加密通信，一个是数字签名。最著名的公钥密码学的算法有两个，一个是 RSA 一个是 ECC 。]]></content>
      <categories>
        <category>信息安全概念</category>
      </categories>
      <tags>
        <tag>concepts</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实习生]]></title>
    <url>%2F2019%2F04%2F09%2F%E5%AE%9E%E4%B9%A0%E7%94%9F%2F</url>
    <content type="text"><![CDATA[​ 最近一直都没有更新，一方面杂事太多，一方面心情太差，被一些事情折磨得感觉每分钟都很煎熬。不说这些了，说自己的新身份：实习生。 实习类型​ 这学期课程比较少，而且导师太忙，迟迟不给我们安排课题，自己在实验室向一个无头苍蝇一样，学学这个，再学学那个，始终觉得，这不是适合自己的模式。于是，偷偷找了份实习。 ​ 国内的一些民营大厂一般是没有日常实习的，尤其是我们这个方向（Digital IC），比如业界代表：华为，其只有面对应届生的暑期实习通道，对于我们这些平时相对靠前的人来说，是不开放实习的。讲到这里，还想再提一下前几天去的海思内部交流会。因为是内部，所以相对接触到了很多比较新的数据和信息。在和一个泰山核项目负责人梁老师的交流过程中发现，菊花厂对实习生培养是真的下功夫，一般会分配师傅手把手带，而且内部学习资源之丰富，实在是令人艳羡。明年如果有机会的话，想去体验一把。 ​ 在实习僧上投递的，投了两家，一个是华为，当然这个肯定是不合格，因为不是2020届；第二个就是现在这个，国有大厂兆芯，因为申的岗位过期了，所以安排到了数字后端部门。想了想也觉得无所谓，全流程，接触哪个环节都有必要，没必要从一开始就把自己限制的过于狭隘。 实习环境​ 兆芯主要做自主可控的CPU，以及主板配套芯片。因为是收购的台湾威盛，所以拿到的也是X86架构的授权，目前应该是国内唯一一家。即其CPU可以做出跑Windows的CPU。因为有很多和政府部门的合作，所以保密级别挺高的，其他的自己也就不知道了，毕竟只是一个没有什么权限的小小实习生。 ​ 公司管理很正规，一些内部的资源站，还有员工网站做的都挺好的。所以，这几天自己除了linux shell使用的更溜了以外，还学到了很多别的东西。比如整个office的办公生态，outlook邮件管理，skype等等，还有工作的大概氛围。 ​ 初来乍到，一些具体的讨论还不知道怎样去说，等再过一阵再回来补上吧！ 初步感受​ 我需要做的工作并不难，只要学一下，挺容易上手的。主要负责工作站的维护和一些日常的杂活，做完该做的，剩下的时间基本就可以由自己支配了。所以，这里几乎是不怎么管实习生的……具体的后边再说吧！]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[hexo入坑-图片上传]]></title>
    <url>%2F2019%2F03%2F21%2Fhexo%E5%85%A5%E5%9D%91-%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0%2F</url>
    <content type="text"><![CDATA[​ 这两天对markdown有点着魔，连做学习笔记都在用Typora写markdown了。本来，Typora插入图片是很方便的，可是偏偏自己还又入了hexo的坑。单纯的用Typora写文章的话，无论插入本地图片还是网络图片都是没问题的，如果需要hexo生成html的话，本地图片上传就会出现一些“坑”。下面是来自“坑里”的一线报道。 弃疗方案更改图片目录方法​ 在网上看过一些贴子，说直接把图片放到hexo会查找的目录，然后用绝对路径或者相对路径引用就可以啦。觉得这个方法甚好，毕竟不需要其他的操作。说说自己的尝试吧： hexo根目录/source/_posts/images 对，我就是在本地文章的那个路径，新建了images，失败。然后改到source下，还是失败。而且相对路径、绝对路径都尝试过了，不好使。 hexo根目录/themes/source/images 失败。。。。坑太深了 综上所述，失败。而且我觉得配置文件里应该有图片查找路径啊类似项的，结果没有….. hexo中安装本地图片上传插件​ 第一种简单的方法失败，然后尝试第二种。先说结果吧，成功了。 先安装”hexo-asset-image”这个插件 1npm install hexo-asset-image --save 然后你新建文章的话，就会发现在_posts下有一个和文章名字同名的文件夹，直接把图片放到里边就可以了。然后引用的话直接写 “[图片别名] (图片.jpg)” 这样就可以啦。图片前连路径都不用加。 ​ 结果是，我自己并没有采用这种方案，因为实在太繁琐了！首先我用Typora，你不给图片加路径的话，在编辑器里根本看不到图片，体验实在不好（这个已经有大佬解决了，可以修改插件的代码，把插件对图片路径的修改延后一项，看这里）。其次，每次我都得把图片放进那个目录里，（虽然Typora支持自动复制到指定路径），感觉不喜欢本地有这么多垃圾。 我的方案​ 尝试了上边的几种，最后还是走了“云”的道路。果然，想要体验的话，没有捷径可以走。s 注册七牛云账号，并且实名认证。新建自己的一个资源空间 win下的图片自动上传工具，我用的是qImage，这里是下载以及使用教程。 ​ 不得不说这个图片自动上传工具做的太好了，剪贴板里边的东西，快捷键自动上传。实在是方便。不过作者说的截图长传，目前在我这还过不了。报错是，路径找不到。自己不太理解，明明截完图后，这张图也是在剪贴板里的，却总是上传失败。截图只能是放在一个地方（比如说聊天窗口），再选中图片ctrl+c一遍，才能加快捷键（ctrl+alt+v）上传成功，不然没戏。。。这个坑后续看能不能填上，先把报错放在下面。 总结​ markdown真香，hexo真香。]]></content>
      <categories>
        <category>工具使用</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>工具使用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开“更”大吉]]></title>
    <url>%2F2019%2F03%2F19%2F%E5%BC%80%E2%80%9C%E6%9B%B4%E2%80%9D%E5%A4%A7%E5%90%89%2F</url>
    <content type="text"><![CDATA[我的个人博客​ 从今天起，本站就作为本人的个人博客使用啦。 ​ 以前总是会在各种博客上看到对自己很有用的“脱坑指南”，心里对这些大神甚是敬仰，所以自己也是不止一次动过写博客的念头。甚至，自己还开通了微信公众号，尝试着写下自己的生活经历，还有学习以及项目上遇到的一些问题，真是羞愧。。。公众号目前只发出过一篇文章，而且还不是关于项目的，其他都还在素材库里安静地躺着。 缘起​ 虽然很菜吧，但是写博客的心还是一直有的！直到有一天，在学习github使用的时候，接触到了几篇博客，其中一个博主（点我膜拜）做的博客界面实在是太赞了！就是那种一见钟情的感觉，瞬间就被美到了！界面简洁，没有广告，整体显得也很大气，很“高端”。原谅我语文功底太差，遇见这种情形，会用的形容词就这么几个!。然后自己就一发不可收拾了。 情深​ 见了一面，就陷进去了。然后自己大致了解了一下基于Hexo静态博客的大致原理，就吭哧吭哧搞起来了，几乎整整两天时间。虽然后续还有不少要维护和美化的，但搞到现在这种程度，着实难为一个底层“硅农”了！曾经自己一度还想着：“怎么也要一步到位，将自己的博客做到那种非常高端酷炫大气的境界，然后推出自己的第一篇文章来”。理智还是获胜了，搞成那样的话，估计我又得扔进去几天。干脆先扔上来一个瞎bb的文章，来给自己的站点开个光。 ​ Hexo是一个静态博客（网页）的生成工具，然后其搭配github或者codinghub的话，就可以实现将自己的静态博客托管到上边，而不需要定期维护，或者交付费用，接收广告啥的。关键是界面漂亮！Hexo在github上用户很广，所以有很多主题可以去选择，不过我最喜欢的还是这个Next的简洁版本了，干干净净的，很舒服。有一点需要吐槽的就是，主题做定制的时候，用户接口竟然是直接去修改代码！！让一个没有做过前端开发的人实在头疼，还好有各种教程贴的神助攻。 ​ 下面总结一下博客搭建以及定制美化的过程。（好多坑） 安装Git，安装Node.js，安装hexo 参考这个 坑1：Node.js最好选择默认安装路径，不然会有环境变量的问题，导致npm这个包管理工具在git_bash中找不到命令，后续所有步骤都会受影响。 建个人仓，关联github 坑2：有个ssh公钥的问题。这个需要在github个人仓里的setting添加，而且后续在本地端git_bash中连接调试的时候，如果报错，是因为少生成了一个文件。这时候在命令行里人家问(Yes/No)?一定要记得敲Yes，会把这个缺失的文件补上，后续的连接和文章部署才不会出问题。 hexo基本配置，主题更换以及定制和美化 坑max：这是最耗费时间的地方，尤其是对于前端白痴加强迫症的我来说。坑太多，所以就不一一总结了。反正让我吃惊的是，细节到，菜单栏的每一项，网站的每一个功能，比如：站点访问人数统计，文章访问统计，评论功能开通，还有其他美化的地方，竟然都需要深入到底层去改css代码。真是刺激…… Markdown文件编辑器Typora 坑4：hexo文章发布的都是.md格式的文件，自己这两天学了一下，感觉这种写作方式真是不错，不用鼠标点来点去了，直接上手敲。结合这款Typora工具，体验还不错。但是！！就在写这个有序列表的时候，我发现自己出不去了，不能进入下一个无格式的段落了。真是醉了，打开源代码窗口，把之前的段落标记符，复制到下一段的段首就可以退出列表了。或者直接点下一行应该也可以。 ​ 折腾了将近两天，发现一总结就上面三段，真是羞愧。关键是，自己没有中间过程留图的习惯，所以内容感觉“有点湿”。反正主要看的人还是自己吧。。。。 定终身​ 既然说了这是给未来自己的一份礼物，所以基本就不会停更了。陆续会把自己的个人总结还有项目经历放上来，学习笔记也会放一些。关键是用markdown格式写学习笔记真的是太舒服了！！ ​ 除了更新博客外，主题界面还会再做一些小修改。比如背景图片轮播、代码段格式、以及文章格式优化。其他的花里胡哨的，特效一类的，不折腾，拉低自己的level。哈哈. ​ 还有hexo本地的一些配置，github上这个仓分支的建立，以实现多台电脑维护个人博客。后续都搞起来。 总结​ 希望这个小网站能成为自己的一个小助力，但愿自己能在不务正业成为大神的道路上越走越远！]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>工具使用</tag>
      </tags>
  </entry>
</search>
